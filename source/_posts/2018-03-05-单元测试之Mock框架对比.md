# 单元测试之Mock框架对比

## 概述
在开发过程中，UT是必不可少的一环，无论是功能的验证，还是统计覆盖率，或者是增加代码可维护性（利于重构后的功能验证），UT都发挥其作用。在写UT时，mock是必须要有的，下面对当前主流的几个Java代码Mock框架做简单介绍，便于不通需求下的选择。
## Mock 框架
### 框架对比
Mock Toolkit有许多，比较常见的有EasyMock, Jmock和JMockit等等，到底选哪个呢，Jmockit的官网上有个特性对比列表，很详细：
![Features对比图](https://github.com/GangZhang/gangzhang.github.io/blob/master/images/Mock%20features.png?raw=true)

我们先写一个简单的测试类，以下Mock都基于该测试类进行：

```java
public class MockClazz {

    public String run(String name) {
        System.out.println(name);
        return name + " begin run...";
    }

    public static String sleep (String name) {
        System.out.println(name);
        return name + " begin sleep...";
    }

    private String eat(String name) {
        System.out.println(name);
        return name + " begin eat...";
    }

    public String getEatInfo(String name) {
        return eat(name);
    }

    public final String create(String name) {
        return name;
    }
}
```

#### 1.easymock
easymock是比较早的一个mock框架，做一次mock需要先创建一个mock对象，然后录制mock代码，把mock对象切换到播放状态，执行单元测试，最后再验证mock对象是否按照录制的mock行为执行。
引入easymock的依赖:

```xml
<dependency>
    <groupId>org.easymock</groupId>
    <artifactId>easymock</artifactId>
    <version>3.4</version>
</dependency>
```
编写mock代码，分为五个步骤:

```java
//1. 创建mock对象
MockClazz mockClazz = EasyMock.createMock(MockClazz.class);
//2. 录制mock对象的预期行为和输出
EasyMock.expect(mockClazz.run(EasyMock.anyString())).andReturn("mocked string for run");
//3. 将mock对象切换到播放状态
EasyMock.replay(mockClazz);
//4. 调用mock对象方法进行测试
String actualString = mockClazz.run("name");
Assert.assertEquals("mocked string for run", actualString);
//5. 对mock对象的行为进行验证,验证mock的对象是否按照录制的行为发生
EasyMock.verify(mockClazz);

String eatInfo = mockClazz.getEatInfo("aa");
System.out.println(eatInfo);
```
这样我们就使用easymock完成了一个对象的mock测试。
在上面的例子中，我们只mock了run这个方法，那没有被mock的方法，在调用的时候会出现什么问题？

其中，`getEatInfo`代码在被执行时，会抛出如下异常：

```java
java.lang.AssertionError:
Unexpected method call MockClazz.getEatInfo(“aa”):
at org.easymock.internal.MockInvocationHandler.invoke(MockInvocationHandler.java:44)
...
```
可见easymock如果其中一个方法没有被mock但是被调用了，就会抛异常。

easymock**不支持private,final,static等方法的mock**。
#### 2.mockito
mockito是在easymock之后出现的，相对于easymock来说，mockito少了对象状态切换这一步骤。
引入mockito的依赖：

```java
<dependency>
     <groupId>org.mockito</groupId>
     <artifactId>mockito-all</artifactId>
     <version>2.0.2-beta</version>
</dependency>
```

编写mockito的mock代码，分四个步骤:

```java
//1. 创建mock对象
MockClazz mockClazz = Mockito.mock(MockClazz.class);
//2. 录制mock代码
Mockito.when(mockClazz.run("A")).thenReturn("B");
//3. 执行单元测试
String actual = mockClazz.run("A");
Assert.assertEquals(actual, "B");
//4. 校验mock对象的行为是否按照mock执行
Mockito.verify(mockClazz).run("A");

String eatInfo = mockClazz.getEatInfo("aa");
System.out.println(eatInfo);
```
和easymock相比，mockito少了一个环节，就是把对象切换到播放状态。
上面的代码中我们mock了run方法，但是`getEatInfo`方法没有被mock,调用这个方法会出现什么问题?

此时返回null，按照mockito的官方文档，没有被mock的方法返回默认值，具体可以看mockito的官方文档。
那么mockito如何保证不被mock的代码按照原来的逻辑输出呢？

>* 通过doCallRealMethodl来实现:

```java
MockClazz mockClazz = Mockito.mock(MockClazz.class);
Mockito.doCallRealMethod().when(mockClazz).run("A");
String actual = mockClazz.run("A");
// A begin run... 原样执行
System.out.println(actual);

// null 返回默认值
System.out.println(mockClazz.run("B"));
```

>* 通过spy来实现

```java
// 注意这里需要new一个
MockClazz mockClazz = Mockito.spy(new MockClazz());
Mockito.when(mockClazz.run("A")).thenReturn("B");

String actual = mockClazz.run("C");
// 输出[C begin run...],原样输出忽略mock逻辑
System.out.println(actual);
```
此时mockClazz.run(“C”)直接按照原来的代码执行，忽略mock逻辑。
在使用spy的时候需要注意一个点，看下面两段代码:

```java
MockClazz mockClazz = Mockito.spy(new MockClazz());
Mockito.when(mockClazz.run("A")).thenReturn("B");
// 实际执行run的代码,只是修改返回值（先输出A,再返回B)
System.out.println(mockClazz.run("A"));
```
这段代码只是修改了返回值，实际代码逻辑被执行了，也就是说这种mock逻辑只是mock了返回值，类似SpringAOP在方法返回的时候拦截一下修改了返回值。

```java
MockClazz mockClazz = Mockito.spy(new MockClazz());
Mockito.doReturn("B").when(mockClazz).run("C");
// 根本不执行run的代码,直接返回
System.out.println(mockClazz.run("C"));
```
这段代码不仅该了返回值，同时也真正的代码一行也不会执行。

> 注意这两种写法的微妙区别
> 
Mockito.doReturn(“B”).when(mockClazz).run(“C”);
Mockito.when(mockClazz.run(“A”)).thenReturn(“B”);

mockito**不支持private,final,static等方法的mock**。

#### 3.powermock
powermock实在easymock和mockito的基础上扩展而来的，easymock和mockito不能解决private,final,static等方法的mock，powermock为此提供了解决方案。powermock需要和easymock或者mockito配合起来一起使用。

引入依赖:

```xml
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-api-mockito</artifactId>
    <version>1.5</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.powermock</groupId>
    <artifactId>powermock-module-junit4</artifactId>
    <version>1.5</version>
    <scope>test</scope>
</dependency>
```

```java
@RunWith(PowerMockRunner.class)
@PrepareForTest( { MockClazz.class })
public class MockTest {

    @Test
    public void testMockStatic() {
        // 静态方法的mock
        PowerMockito.mockStatic(MockClazz.class);
        PowerMockito.when(MockClazz.sleep("A")).thenReturn("B");
        System.out.println(MockClazz.sleep("A"));
        PowerMockito.verifyStatic();
    }

    @Test
    public void testMockPrivate() throws  Exception {
        // 私有方法的mock,getEatInfo=>eat,eat是私有方法
        MockClazz mockClazz = PowerMockito.mock(MockClazz.class);
        PowerMockito.when(mockClazz, "eat", "A").thenReturn("mock");
        PowerMockito.doCallRealMethod().when(mockClazz).getEatInfo("A");
        System.out.println(mockClazz.getEatInfo("A"));
    }

    @Test
    public void testMockFinal() {
        // final方法的mock
        MockClazz mockClazz = PowerMockito.mock(MockClazz.class);
        PowerMockito.when(mockClazz.create("A")).thenReturn("B");
        System.out.println(mockClazz.create("A"));
    }
}
```

#### jmockit
jmockit是一个轻量级的mock框架，内部采用ASM来修改字节码。

引入依赖：

```xml
<dependency>
    <groupId>com.googlecode.jmockit</groupId>
    <artifactId>jmockit</artifactId>
    <version>1.0</version>
</dependency>
```
具体mock的代码如下:

```java
@RunWith(JMockit.class)
public class MockTest {

    @Mocked
    MockClazz mockClazz = new MockClazz();

    @Test
    public void testExpectations() { // 全局mock抛异常
        new Expectations() {
            {
                mockClazz.getEatInfo("A");
                returns("B");
            }
        };

        // 被mock的方法,返回mock后的值
        System.out.println(mockClazz.getEatInfo("A"));
        // 没有被mock的方法,mockit.internal.UnexpectedInvocation,jmocit对run没有进行mock
        System.out.println(mockClazz.run("A"));
    }

    @Test
    public void testNonExpectations() { //全局mock返回缺省值

        new NonStrictExpectations() {
            {
                mockClazz.getEatInfo("A");
                returns("B");
            }
        };

        // 被mock的方法,返回mock后的值
        System.out.println(mockClazz.getEatInfo("A"));
        // 没有被mock的方法,返回默认值,jmockit对run方法也进行了mock
        System.out.println(mockClazz.run("A"));
    }

    @Test
    public void testMockStatic() {
        // mock静态方法
        new NonStrictExpectations() {
            {
                MockClazz.sleep("A");
//                result = "B";
                returns("B");
            }
        };
        System.out.println(MockClazz.sleep("A"));
    }

    @Test
    public void testMockPrivate() {
        final MockClazz obj = new MockClazz();
        new NonStrictExpectations(obj) {
            {
                // 私有方法mock
                this.invoke(obj, "eat", "A");
                returns("B");
            }
        };
        // 私有方法被mock了
        System.out.println(obj.getEatInfo("A"));
        // run方法不会被mock,走真实逻辑
        System.out.println(obj.run("A"));
    }
}
```

> 注意：
> 
> 1.NonStrictExpectations返回缺省值针对没有mock的方法
> 
> 2.Expectations针对没有mock的方法直接抛异常

## spring-boot-test

T.B.C.

## 参考
[1] [Java 单元测试mock框架](http://yangbolin.cn/2016/07/17/java-ut-mock-framework/)

[2] [GUIDE TO TESTING CONTROLLERS IN SPRING BOOT](https://thepracticaldeveloper.com/2017/07/31/guide-spring-boot-controller-tests/)

[3] [jmockit中文社区](http://jmockit.cn/)

[4] [jmockit简单使用](http://blog.csdn.net/zero__007/article/details/49280827)

[5] [easymock doc](http://easymock.org/user-guide.html)

[6] [power mock](https://github.com/powermock/powermock)

[7] [Mock框架对比](http://billben.iteye.com/blog/1872196)

[8] [Spring boot controller test](https://thepracticaldeveloper.com/2017/07/31/guide-spring-boot-controller-tests/)

[9] [redis mock](https://dzone.com/articles/java-redis-mock)